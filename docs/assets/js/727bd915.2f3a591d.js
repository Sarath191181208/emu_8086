"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[325],{3849:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/27-10-2023 Refactor","metadata":{"permalink":"/emu_8086/blog/27-10-2023 Refactor","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/27-10-2023 Refactor.mdx","source":"@site/blog/27-10-2023 Refactor.mdx","title":"\ud83d\udee0\ufe0f Refactor","description":"\ud83d\udee0\ufe0f Refactor conditional check of variable type into the evaluate_ins function And added ByteIndexedAddressing in Assembly8086Tokens","date":"2023-10-27T15:49:00.000Z","formattedDate":"October 27, 2023","tags":[],"readingTime":1.905,"hasTruncateMarker":false,"authors":[{"name":"Vangipuram Srinivasa Sarath Chandra","title":"Tech enthusiast","url":"https://github.com/Sarath191181208","image_url":"https://avatars.githubusercontent.com/u/74459981?v=4","imageURL":"https://avatars.githubusercontent.com/u/74459981?v=4"}],"frontMatter":{"authors":{"name":"Vangipuram Srinivasa Sarath Chandra","title":"Tech enthusiast","url":"https://github.com/Sarath191181208","image_url":"https://avatars.githubusercontent.com/u/74459981?v=4","imageURL":"https://avatars.githubusercontent.com/u/74459981?v=4"}},"nextItem":{"title":"Pop Support","permalink":"/emu_8086/blog/26-10-2023 Added POP support"}},"content":"\ud83d\udee0\ufe0f Refactor conditional check of variable type into the evaluate_ins function And added ByteIndexedAddressing in Assembly8086Tokens\\r\\n\\r\\n## Refactor conditional check\\r\\n\\r\\n- Refactored conditional check of variable type into the evaluate_ins function\\r\\n  The code base was having this type of conditional checks for checking if the variable type is defined as Word (or) as byte\\r\\n  The fowlling is the example of what I am talking about:\\r\\n\\r\\n```rust\\r\\n// ./src-tauri/src/compiler/parsers/mov.rs\\r\\nlet mov_ins = if is_variable_defined_as_16bit(\\r\\n    &variable_abs_offset_map,\\r\\n    get_token_as_label(&high_token),\\r\\n) {\\r\\n    0xC7\\r\\n} else {\\r\\n    0xC6\\r\\n};\\r\\n```\\r\\n\\r\\nThis is a repetative logic and we can mess up quite easily therefore we have refactored this into the evaluate_ins function the following is the example of the same:\\r\\n\\r\\n```rust\\r\\n// ./src-tauri/src/compiler/parsers/pattern_extractors/utils.rs 181:5\\r\\nlet var_type = variable_abs_address_map\\r\\n    .get(label)\\r\\n    .unwrap_or(&(VariableType::Word, 0))\\r\\n    .0;\\r\\nvariable_type = Some(var_type);\\r\\n```\\r\\n\\r\\n## Removal of parsing chracter in parse fn and moved it into evaluate ins\\r\\n\\r\\nThe `parse_two_arguments_line` was incharge of handing the substitution of variables and labels into their respective addresses and values. This intrun created a lot of duplicated logic and was getting hard to maintain. Thus, this logic has now been moved into the `evaluate_ins` function which is now incharge of handlig the substitution of variables and labels into their respective addresses and values.\\r\\n\\r\\nThis is what the `parse_two_arguments_line` was doing before: \\r\\n```rust \\r\\nmatch high_token{\\r\\n    match low_token{ \\r\\n        Assembly8086Tokens::Character(label) => {\\r\\n            let addr_bytes_or_num = get_label_address_or_push_into_ref();\\r\\n            match addr_bytes_or_num{\\r\\n                bytes => AddressingMode::RegisterAndAddress\\r\\n                num => AddressingMode::Registers16bitNumber\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n```\\r\\n\\r\\nThis logic has now been converted into the `evaluate_ins` fn where it is already being done.\\r\\n\\r\\n## Addition of ByteIndexedAddressing in Assembly8086Tokens\\r\\n\\r\\nI have recently known that there exists ByteIndexedAddressing in the 8086 processor, it is a mode where you can change/access byte of the memory like when defining the variable as byte. You can also do this in a differnent way therefore to merge all of the uses into a sinlge entity to represent and match easily I have added ByteIndexedAddressing in Assembly8086Tokens. The following is the example of the same:\\r\\n\\r\\nMy discovery: \\r\\n```asm6502\\r\\nMOV b.[BX], 0x0A ; moves 0x0A into the byte of the memory pointed by BX\\r\\nMOV w.[BX], 0x0A ; moves 0x00_0A into the word of the memory pointed by BX\\r\\n```\\r\\n\\r\\nAs this is the case to represent both `b.[BX]` and `var db` I have added ByteIndexedAddressing in Assembly8086Tokens."},{"id":"/26-10-2023 Added POP support","metadata":{"permalink":"/emu_8086/blog/26-10-2023 Added POP support","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/26-10-2023 Added POP support.mdx","source":"@site/blog/26-10-2023 Added POP support.mdx","title":"Pop Support","description":"Compilation of the pop instruction","date":"2023-10-26T05:36:19.000Z","formattedDate":"October 26, 2023","tags":[],"readingTime":1.04,"hasTruncateMarker":false,"authors":[{"name":"Vangipuram Srinivasa Sarath Chandra","title":"Tech enthusiast","url":"https://github.com/Sarath191181208","image_url":"https://avatars.githubusercontent.com/u/74459981?v=4","imageURL":"https://avatars.githubusercontent.com/u/74459981?v=4"}],"frontMatter":{"authors":{"name":"Vangipuram Srinivasa Sarath Chandra","title":"Tech enthusiast","url":"https://github.com/Sarath191181208","image_url":"https://avatars.githubusercontent.com/u/74459981?v=4","imageURL":"https://avatars.githubusercontent.com/u/74459981?v=4"}},"prevItem":{"title":"\ud83d\udee0\ufe0f Refactor","permalink":"/emu_8086/blog/27-10-2023 Refactor"}},"content":"## Compilation of the pop instruction\\r\\n\\r\\n|         Operand          |          Opcode          |                       Description                       | Example instruction |\\r\\n| :----------------------: | :----------------------: | :-----------------------------------------------------: | :-----------------: |\\r\\n|          reg16           |          0x58+rw           |               Pop top of stack into reg16               |       ` pop ax `        |\\r\\n|          mem16           |    0x8F 0x06 16BIT-addr    |               Pop top of stack into mem16               |    `pop [0x0100]`     |\\r\\n|  indexed with no offset  |      0x8F 0x00..0x07       |        Pop top of stack into index given by regs        |     `pop [bx+si]`     |\\r\\n| indexed with byte offset | 0x8F 0x40..0x47 16bit-addr | Pop top of stack into index given by regs + byte offset |  `pop [bx+0x01]`   |\\r\\n| indexed with word offset | 0x8F 0x80..0x87 16bit-addr | Pop top of stack into index given by regs + word offset | `pop [bx+0x0100]`  |\\r\\n\\r\\n## Execution of the pop instruction\\r\\n\\r\\nMade the `pop` instruction execution working.\\r\\nAddressing modes of the `pop` instruction implemented are:\\r\\n\\r\\n- Register addressing mode, ex - `pop ax`\\r\\n- Direct addressing mode, ex - `pop [0x1234]`\\r\\n- Variable addressing mode, ex - `pop [var]`\\r\\n- Indirect addressing mode, ex - `pop [bx]`\\r\\n- Indexed addressing mode, ex - `pop [bx+si]`\\r\\n\\r\\nAlgorithm:\\r\\n```\\r\\noperand = SS:[SP] (top of the stack)\\r\\nSP = SP + 2\\r\\n```"}]}')}}]);