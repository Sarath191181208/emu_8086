"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2938],{5507:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var n=a(7462),r=(a(7294),a(3905));const s={authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4"}},i="\ud83d\udee0\ufe0f Refactor and Exec of AND",o={permalink:"/emu_8086/blog/2023/10/31/",editUrl:"https://github.com/Sarath191181208/emu_8086/tree/main/docusaurus/blog/2023-10-31.mdx",source:"@site/blog/2023-10-31.mdx",title:"\ud83d\udee0\ufe0f Refactor and Exec of AND",description:"\ud83d\udee0\ufe0f Refactor of common parsing while exec of reg as first ins",date:"2023-10-31T00:00:00.000Z",formattedDate:"October 31, 2023",tags:[],readingTime:1.215,hasTruncateMarker:!1,authors:[{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}],frontMatter:{authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}},prevItem:{title:"Support for memory, reg addressing for 2 operand instructions",permalink:"/emu_8086/blog/2023/11/1/"},nextItem:{title:"Support for and instruction compilation",permalink:"/emu_8086/blog/2023/10/30/"}},l={authorsImageUrls:[void 0]},u=[{value:"\ud83d\udee0\ufe0f Refactor of common parsing while exec of reg as first ins",id:"\ufe0f-refactor-of-common-parsing-while-exec-of-reg-as-first-ins",level:2},{value:"Execution of <code>AND</code> instruction",id:"execution-of-and-instruction",level:2}],c={toc:u},m="wrapper";function f(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"\ufe0f-refactor-of-common-parsing-while-exec-of-reg-as-first-ins"},"\ud83d\udee0\ufe0f Refactor of common parsing while exec of reg as first ins"),(0,r.kt)("p",null,"The logic of register as first instruction is always similar for example\n",(0,r.kt)("inlineCode",{parentName:"p"},"TEST AX, BX")," -> bytes ","[ 0x85, 0xD8 ]",", ",(0,r.kt)("inlineCode",{parentName:"p"},"ADD AX, BX")," -> bytes ","[ 0x01, 0xD8 ]"," and so on.\nwhile exec 0xD8 is always the register for instructions. Therefore, the logic of parsing the register is common for all the instructions. So, I have refactored the code to make it more readable and maintainable.\nThe new functions are "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"consume_bytes_and_parse_8bit_reg_as_first_arg_double_ins")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"consume_bytes_and_parse_16bit_reg_as_first_arg_double_ins"))),(0,r.kt)("p",null,"The functions are used in the fowlling ways "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"// For 16bit registers\nself.consume_bytes_and_parse_16bit_reg_as_first_arg_double_ins(\n    mem,\n    &|cpu: &mut CPU, val1: u16, val2: u16| -> Option<u16> {\n        let res = val1 & val2;\n        cpu.set_test_ins_flags_from_16bit_res(res);\n        None\n    },\n)\n\n// For 8bit registers\nlet exec_fn = &|cpu: &mut CPU, val1: u8, val2: u8| -> Option<u8> {\n    let res = val1 & val2;\n    cpu.set_test_ins_flags_from_8bit_res(res);\n    None\n};\nself.consume_bytes_and_parse_8bit_reg_as_first_arg_double_ins(mem, exec_fn);\n")),(0,r.kt)("h2",{id:"execution-of-and-instruction"},"Execution of ",(0,r.kt)("inlineCode",{parentName:"h2"},"AND")," instruction"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AND")," instruction is executed in the following way"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"// For 16bit registers\nlet res = op1 & op2;\ncarry_flag = false;\noverflow_flag = false;\nzero_flag = res == 0;\nnegative_flag = res & 0x8000 != 0;\npairity_flag = (res & 0xFF).count_ones() % 2 == 0;\n\n// For 8bit registers\nlet res = op1 & op2;\ncarry_flag = false;\noverflow_flag = false;\nzero_flag = res == 0;\nnegative_flag = res & 0x80 != 0;\npairity_flag = res.count_ones() % 2 == 0;\n")))}f.isMDXComponent=!0}}]);