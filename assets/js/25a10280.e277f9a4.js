"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[31],{7898:(e,t,n)=>{n.d(t,{PM:()=>m,PP:()=>d,Py:()=>s,VY:()=>r,W7:()=>c,YH:()=>p,kp:()=>E,lh:()=>u,mL:()=>o,qT:()=>h,vR:()=>i});var l=n(7294),a=n(614);function r(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is either a general-purpose register or a segment register."),l.createElement("p",null,"Example:"),l.createElement(a.Z,{language:"asm6502"},e.instructionName," AX, BX ",l.createElement("br",null),e.instructionName," BL, CH"),l.createElement("hr",null))}function i(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a constant."),l.createElement("p",null,"Example:"),l.createElement(a.Z,{language:"asm6502"},e.instructionName," AX, 0FFh ",l.createElement("br",null),e.instructionName," BX, 0Bh ",l.createElement("br",null),e.instructionName," CL, 0h"),l.createElement("hr",null))}function m(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location."),l.createElement("p",null,"Example:"),l.createElement(a.Z,{language:"asm6502"},e.instructionName," AX, [0x100] ",l.createElement("br",null),e.instructionName," AL, b.[0x100] ",l.createElement("br",null)),"(or) Alternatively you can specify the memory location using the `variable assignment`",l.createElement("p",null,"Example"),l.createElement(a.Z,{language:"asm6502"},"ORG 100h ",l.createElement("br",null),".DATA ",l.createElement("br",null),"    VAR1 DB 0FFh"," ",l.createElement("br",null),"    VAR2 DW 0Bh"," ",l.createElement("br",null)," ",l.createElement("br",null),"CODE: ",l.createElement("br",null),`    ${e.instructionName} AL, Var1`," ",l.createElement("br",null),`    ${e.instructionName} BX, Var2`," ",l.createElement("br",null),`    ${e.instructionName} CL, b.[Var2]`," ",l.createElement("br",null),`    ${e.instructionName} DX, w.[Var1]`," ",l.createElement("br",null)),l.createElement("hr",null))}function o(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location whose address is contained in a register."),l.createElement("p",null,"Example:"),l.createElement(a.Z,{language:"asm6502"},e.instructionName," AX, [BX] ",l.createElement("br",null),e.instructionName," AL, b.[BX] ",l.createElement("br",null)),l.createElement("hr",null))}function s(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location whose address is contained in a register and an offset."),l.createElement("p",null,"Example:"),l.createElement(a.Z,{language:"asm6502"},e.instructionName," AX, [BX+SI] ",l.createElement("br",null),e.instructionName," AL, b.[BX+SI] ",l.createElement("br",null)),l.createElement("hr",null))}function u(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location whose address is contained in a register and an offset and a displacement."),l.createElement("p",null,"Example:"),l.createElement(a.Z,{language:"asm6502"},e.instructionName," AX, [BX+SI+10h] ",l.createElement("br",null),e.instructionName," AX, [BX+SI+100h] ",l.createElement("br",null),e.instructionName," AL, b.[BX+SI+10h] ",l.createElement("br",null),e.instructionName," AL, b.[BX+SI+100h] ",l.createElement("br",null)),l.createElement("hr",null))}function c(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified as a register while the other operand is specified as a memory location. The second operand is a memory location whose address is contained in a register (or) an offset. The second operand might also have an displacement."),l.createElement("p",null,"Example: "),l.createElement(a.Z,{language:"asm6502",showLineNumbers:!0},"org 100h ",l.createElement("br",null),"data ",l.createElement("br",null),"    VAR DB 0FFh"," ",l.createElement("br",null),"    VAR2 DW 0Bh"," ",l.createElement("br",null),"code: ",l.createElement("br",null),`    ${e.instructionName} BX, Var `,l.createElement("br",null),`    ${e.instructionName} BX, w.[Var] `,l.createElement("br",null),`    ${e.instructionName} BX, w.[Var2] `,l.createElement("br",null)," ",l.createElement("br",null),`    ${e.instructionName} AX, [BX] `,l.createElement("br",null),`    ${e.instructionName} DX, [BX+SI] `,l.createElement("br",null),`    ${e.instructionName} SP, [BX+SI+10h] `,l.createElement("br",null),`    ${e.instructionName} DI, [BX+SI+100h] `,l.createElement("br",null)))}function d(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified as a memory location while the other operand is specified as a register. The first operand is a memory location whose address is contained in a register (or) an offset. The first operand might also have an displacement."),l.createElement("p",null,"Example: "),l.createElement(a.Z,{language:"asm6502",showLineNumbers:!0},"org 100h ",l.createElement("br",null),"data ",l.createElement("br",null),"    VAR DB 0FFh"," ",l.createElement("br",null),"    VAR2 DW 0Bh"," ",l.createElement("br",null),"code: ",l.createElement("br",null),`    ${e.instructionName} Var, BX `,l.createElement("br",null),`    ${e.instructionName} w.[Var], BX `,l.createElement("br",null),`    ${e.instructionName} w.[Var2], BX `,l.createElement("br",null)," ",l.createElement("br",null),`    ${e.instructionName} [BX], AX `,l.createElement("br",null),`    ${e.instructionName} [BX+SI], DX `,l.createElement("br",null),`    ${e.instructionName} [BX+SI+10h], SP `,l.createElement("br",null),`    ${e.instructionName} [BX+SI+100h], DI `,l.createElement("br",null)))}function h(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified as a memory location while the other operand is specified as a constant. The first operand is a memory location whose address is contained in a register (or) an offset. The first operand might also have an displacement."),l.createElement("p",null,"Example: "),l.createElement(a.Z,{language:"asm6502",showLineNumbers:!0},`    ${e.instructionName} [BX], 0FFh `,l.createElement("br",null),`    ${e.instructionName} [BX+SI], 0FFh `,l.createElement("br",null),`    ${e.instructionName} [BX+SI+10h], 0FFh `,l.createElement("br",null),`    ${e.instructionName} [BX+SI+100h], 0FFh `,l.createElement("br",null)))}function E(e){return l.createElement(l.Fragment,null,l.createElement("p",null,"This is a mode in which the operand is specified as a memory location while the other operand is specified as a constant. The first operand is a memory location whose address is specified directly in the instruction."),l.createElement("p",null,"Example: "),l.createElement(a.Z,{language:"asm6502",showLineNumbers:!0},"org 100h ",l.createElement("br",null),"data ",l.createElement("br",null),"    VAR DB 0FFh"," ",l.createElement("br",null),"    VAR2 DW 0Bh"," ",l.createElement("br",null),"code: ",l.createElement("br",null),`    ${e.instructionName} [Var], 0xFF `,l.createElement("br",null),`    ${e.instructionName} [Var2], 0x100 `,l.createElement("br",null),`    ${e.instructionName} [0x100], 0x100+20 `,l.createElement("br",null),`    ${e.instructionName} [0x100+10h], 0FFh `))}function p(e){return l.createElement("table",null,l.createElement("thead",null,l.createElement("tr",null,l.createElement("th",null,"Operand"),l.createElement("th",null,"Opcode"),l.createElement("th",null,"Size(bytes)"),l.createElement("th",null,"Example instruction"))),l.createElement("tbody",null,l.createElement("tr",null,l.createElement("td",null,"reg16, indirect mem"),l.createElement("td",null,e.reg_16bit_and_anything_ins," 0x00..=0x3F"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} AX, [BX]`)),l.createElement("tr",null,l.createElement("td",null,"reg16, direct mem"),l.createElement("td",null,e.reg_16bit_and_anything_ins," ","0x06 | reg_idx << 3"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} DX, [0x100]`)),l.createElement("tr",null,l.createElement("td",null,"reg16, indirect mem with 8bit offset"),l.createElement("td",null,e.reg_16bit_and_anything_ins," 0x40..=0x7F 0x00..=0xFF"),l.createElement("td",null,"3"),l.createElement("td",null,`${e.instructionName} AX, [BX+0x10]`)),l.createElement("tr",null,l.createElement("td",null,"reg16, indirect mem with 16bit offset"),l.createElement("td",null,e.reg_16bit_and_anything_ins," 0x80..=0xBF 0x00..=0xFF"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} AX, [BX+0x100]`)),l.createElement("tr",null,l.createElement("td",null,"reg16, reg16"),l.createElement("td",null,e.reg_16bit_and_anything_ins," 0xC0..=0xFF"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} AX, BX`)),l.createElement("tr",null,l.createElement("td",null,"reg8, indirect mem"),l.createElement("td",null,e.reg_8bit_and_anything_ins," 0x00..=0x3F"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} AL, [BX]`)),l.createElement("tr",null,l.createElement("td",null,"reg8, direct mem"),l.createElement("td",null,e.reg_8bit_and_anything_ins," ","0x06 | reg_idx << 3"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} CL, [0x100]`)),l.createElement("tr",null,l.createElement("td",null,"reg8, indirect mem with 8bit offset"),l.createElement("td",null,e.reg_8bit_and_anything_ins," 0x40..=0x7F 0x00..=0xFF"),l.createElement("td",null,"3"),l.createElement("td",null,`${e.instructionName} AL, [BX+0x10]`)),l.createElement("tr",null,l.createElement("td",null,"reg8, indirect mem with 16bit offset"),l.createElement("td",null,e.reg_8bit_and_anything_ins," 0x80..=0xBF 0x00..=0xFF"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} AL, [BX+0x100]`)),l.createElement("tr",null,l.createElement("td",null,"reg8, reg8"),l.createElement("td",null,e.reg_8bit_and_anything_ins," 0xC0..=0xFF"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} AL, BL`)),l.createElement("tr",null,l.createElement("td",null,"indirect mem, reg 16"),l.createElement("td",null,e.indexed_addressing_and_anyting_ins," 0x00..=0x3F"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} [BX+SI], AX`)),l.createElement("tr",null,l.createElement("td",null,"direct mem, reg 16"),l.createElement("td",null,e.indexed_addressing_and_anyting_ins," ","0x06 | reg_idx << 3"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} [0x100], BP`)),l.createElement("tr",null,l.createElement("td",null,"indirect mem with 8bit offset, reg 16"),l.createElement("td",null,e.indexed_addressing_and_anyting_ins," 0x40..=0x7F 0x00..=0xFF"),l.createElement("td",null,"3"),l.createElement("td",null,`${e.instructionName} [BX+SI+0x10], CX`)),l.createElement("tr",null,l.createElement("td",null,"indirect mem with 16bit offset, reg 16"),l.createElement("td",null,e.indexed_addressing_and_anyting_ins," 0x80..=0xBF 0x00..=0xFF"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} [BX+SI+0x100], DX`)),l.createElement("tr",null,l.createElement("td",null,"direct mem, reg 8"),l.createElement("td",null,e.addr_and_8bit_reg," ","0x06 | reg_idx << 3"),l.createElement("td",null,"4"),l.createElement("td",null,`${e.instructionName} [0x100], AL`)),l.createElement("tr",null,l.createElement("td",null,"AL, num"),l.createElement("td",null,e.al_and_num_ins," 0x00..=0xFF 0x00..=0xFF"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} AL, 0x10`)),l.createElement("tr",null,l.createElement("td",null,"AX, num"),l.createElement("td",null,e.ax_and_num_ins," 0x00..=0xFF 0x00..=0xFF"),l.createElement("td",null,"3"),l.createElement("td",null,`${e.instructionName} AX, 0x100`)),l.createElement("tr",null,l.createElement("td",null,"reg16, num16"),l.createElement("td",null,e.reg16bit_and_16bit_num," ",e.reg_num_sub_ins,"+reg_idx 0x00..=0xFF 0x00..=0xFF"),l.createElement("td",null,"3"),l.createElement("td",null,`${e.instructionName} DX, 0x100`)),l.createElement("tr",null,l.createElement("td",null,"reg16, num8"),l.createElement("td",null,e.reg16bit_and_8bit_num," ",e.reg_num_sub_ins,"+reg_idx 0x00..=0xFF"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} CX, 0x10`)),l.createElement("tr",null,l.createElement("td",null,"reg8, num"),l.createElement("td",null,e.reg8bit_and_num," ",e.reg_num_sub_ins,"+reg_idx 0x00..=0xFF"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} AL, 0x10`)),l.createElement("tr",null,l.createElement("td",null,"direct address, num16"),l.createElement("td",null,e.addr16bit_and_16bit_num," ",e.addr_num_sub_ins,"+reg_idx"," ","[0x00..=0xFF 0x00..=0xFF] 0x00..=0xFF 0x00..=0xFF"),l.createElement("td",null,"6"),l.createElement("td",null,`${e.instructionName} [0x100], 0x100`)),l.createElement("tr",null,l.createElement("td",null,"direct address, num8"),l.createElement("td",null,e.addr16bit_and_16bit_num," ",e.addr_num_sub_ins,"+reg_idx"," ","[0x00..=0xFF 0x00..=0xFF] 0x00..=0xFF"," "),l.createElement("td",null,"5"),l.createElement("td",null,`${e.instructionName} [0x100], 0x10`)),l.createElement("tr",null,l.createElement("td",null,"addr8, num"),l.createElement("td",null,e.addr8bit_and_num," ",e.addr_num_sub_ins,"+reg_idx [0x00..=0xFF 0x00..=0xFF] 0x00..=0xFF"),l.createElement("td",null,"2"),l.createElement("td",null,`${e.instructionName} b.[0x100], 0x10`))))}},8474:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>m,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var l=n(7462),a=(n(7294),n(3905)),r=n(7898);const i={authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4"}},m="Support for memory, reg addressing for 2 operand instructions",o={permalink:"/emu_8086/blog/2023/11/1/",editUrl:"https://github.com/Sarath191181208/emu_8086/tree/main/docusaurus/blog/2023-11-1.mdx",source:"@site/blog/2023-11-1.mdx",title:"Support for memory, reg addressing for 2 operand instructions",description:"Changes this day :",date:"2023-11-01T00:00:00.000Z",formattedDate:"November 1, 2023",tags:[],readingTime:3.31,hasTruncateMarker:!1,authors:[{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}],frontMatter:{authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}},prevItem:{title:"Support for execution of OR ins",permalink:"/emu_8086/blog/2023/11/2/"},nextItem:{title:"\ud83d\udee0\ufe0f Refactor and Exec of AND",permalink:"/emu_8086/blog/2023/10/31/"}},s={authorsImageUrls:[void 0]},u=[{value:"Support for memory, reg addressing for 2 operand instructions",id:"support-for-memory-reg-addressing-for-2-operand-instructions",level:2},{value:"\ud83d\udc1eFIX: <code>MOV</code> mem, ax no compiling",id:"fix-mov-mem-ax-no-compiling",level:2},{value:"\ud83d\udc1eFIX: <code>ADD</code> ax, mem not compiling",id:"fix-add-ax-mem-not-compiling",level:2},{value:"\u2728 NEW: +compilation of <code>LEA</code> ins",id:"-new-compilation-of-lea-ins",level:2},{value:"\u2728 NEW: +execution of <code>LEA</code> ins",id:"-new-execution-of-lea-ins",level:2},{value:"\u2728 NEW: +compilation of <code>LES</code> ins",id:"-new-compilation-of-les-ins",level:2},{value:"\u2728 NEW: +execution of <code>LES</code> ins",id:"-new-execution-of-les-ins",level:2},{value:"Compilation of <code>OR</code> ins",id:"compilation-of-or-ins",level:2}],c={toc:u},d="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,l.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Changes this day :"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Added support for memory addressing for 2 operand instructions"),(0,a.kt)("li",{parentName:"ol"},"\ud83d\udc1eFIX: ",(0,a.kt)("inlineCode",{parentName:"li"},"MOV")," mem, ax no compiling"),(0,a.kt)("li",{parentName:"ol"},"\ud83d\udc1eFIX: ",(0,a.kt)("inlineCode",{parentName:"li"},"ADD")," ax, mem not compiling"),(0,a.kt)("li",{parentName:"ol"},"\u2728 NEW: +compilation of ",(0,a.kt)("inlineCode",{parentName:"li"},"LEA")," ins"),(0,a.kt)("li",{parentName:"ol"},"\u2728 NEW: +execution of ",(0,a.kt)("inlineCode",{parentName:"li"},"LEA")," ins")),(0,a.kt)("h2",{id:"support-for-memory-reg-addressing-for-2-operand-instructions"},"Support for memory, reg addressing for 2 operand instructions"),(0,a.kt)("p",null,"This is an example instruction"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"    MOV [0x100], Bx ; This was supported\n    MOV [BX+SI], AX ; Previously This wasn't supported\n")),(0,a.kt)("h2",{id:"fix-mov-mem-ax-no-compiling"},"\ud83d\udc1eFIX: ",(0,a.kt)("inlineCode",{parentName:"h2"},"MOV")," mem, ax no compiling"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"MOV AX, 0x10 + 0x20")," kind of instructions weren't being compiled due to the lexer checking the wrong index for the instruction. This has been fixed in the fowlling way."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"                        &low_token => address_bytes.to_vec()\n                    )\n                );\n                // Removed\n                Ok(i + 3)\n                // Added\n                Ok(tokenized_line.len())\n            }\n        },\n        // MOV AX..DI, var\n")),(0,a.kt)("h2",{id:"fix-add-ax-mem-not-compiling"},"\ud83d\udc1eFIX: ",(0,a.kt)("inlineCode",{parentName:"h2"},"ADD")," ax, mem not compiling"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"ADD AX, [0x100]")," kind of instructions weren't being compiled due to the lexer checking the wrong index for the instruction. This has been fixed in the fowlling way."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"                        &low_token => address_bytes.to_vec()\n                    )\n                );\n                // Removed\n                Ok(i + 3)\n                // Added\n                Ok(tokenized_line.len())\n            }\n        },\n        // ADD AX..DI, var\n")),(0,a.kt)("h2",{id:"-new-compilation-of-lea-ins"},"\u2728 NEW: +compilation of ",(0,a.kt)("inlineCode",{parentName:"h2"},"LEA")," ins"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"LEA")," instruction is used to load the effective address of the source operand into the destination operand. This instruction is used to put the offset address of the source operand in the destination operand. The destination operand is always a register, and the source operand is always a memory operand. The source operand specifies the address of the data. The LEA instruction is useful for accessing table data and executing table lookup operations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"    LEA AX, [0x100] ; AX = 0x100\n    LEA AX, [BX+SI] ; AX = BX + SI\n    LEA AX, [BX+SI+0x100] ; AX = BX + SI + 0x100\n    LEA AX, [BX+SI+0x100+0x200] ; AX = BX + SI + 0x100 + 0x200\n")),(0,a.kt)("h2",{id:"-new-execution-of-lea-ins"},"\u2728 NEW: +execution of ",(0,a.kt)("inlineCode",{parentName:"h2"},"LEA")," ins"),(0,a.kt)("p",null,"The algorithm for the execution of the ",(0,a.kt)("inlineCode",{parentName:"p"},"LEA")," instruction is as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Fetch the instruction."),(0,a.kt)("li",{parentName:"ol"},"Decode the instruction to determine the addressing mode of the source operand."),(0,a.kt)("li",{parentName:"ol"},"Calculate the effective address of the source operand."),(0,a.kt)("li",{parentName:"ol"},"Load the effective address into the destination register."),(0,a.kt)("li",{parentName:"ol"},"Store the result in the destination register.")),(0,a.kt)("h2",{id:"-new-compilation-of-les-ins"},"\u2728 NEW: +compilation of ",(0,a.kt)("inlineCode",{parentName:"h2"},"LES")," ins"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"LES")," instruction is used to load double word register pair with a far pointer. The ",(0,a.kt)("inlineCode",{parentName:"p"},"LES")," instruction is used to load the segment register and the offset into the destination register pair. The destination operand is always a register, and the source operand is always a memory operand. The source operand specifies the address of the data. The ",(0,a.kt)("inlineCode",{parentName:"p"},"LES")," instruction is useful for accessing table data and executing table lookup operations."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"    LES AX, [0x100] ; AX = [0x100], ES = [0x102]\n    LES AX, [BX+SI] ; AX = [BX + SI], ES = [BX + SI + 0x2]\n    LES AX, [BX+SI+0x100] ; AX = [BX + SI + 0x100 ] , ES = [BX + SI + 0x102]\n    LES AX, [BX+SI+0x100+0x200] ; AX = [BX + SI + 0x100 + 0x200], ES = [BX + SI + 0x302]\n")),(0,a.kt)("h2",{id:"-new-execution-of-les-ins"},"\u2728 NEW: +execution of ",(0,a.kt)("inlineCode",{parentName:"h2"},"LES")," ins"),(0,a.kt)("p",null,"The algorithm for the execution of the ",(0,a.kt)("inlineCode",{parentName:"p"},"LES")," instruction is as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Fetch the instruction."),(0,a.kt)("li",{parentName:"ol"},"Decode the instruction to determine the addressing mode of the source operand."),(0,a.kt)("li",{parentName:"ol"},"Calculate the effective address of the source operand."),(0,a.kt)("li",{parentName:"ol"},"Load the effective address into the destination register."),(0,a.kt)("li",{parentName:"ol"},"Store the result in the destination register."),(0,a.kt)("li",{parentName:"ol"},"Load the effective address + 2 into the extra segment register.")),(0,a.kt)("h2",{id:"compilation-of-or-ins"},"Compilation of ",(0,a.kt)("inlineCode",{parentName:"h2"},"OR")," ins"),(0,a.kt)("p",null,"It is used to perform bitwise or operation on the operands the result is stored in the first operand."),(0,a.kt)(r.YH,{instructionName:"OR",reg_16bit_and_anything_ins:11,reg_8bit_and_anything_ins:10,indexed_addressing_and_anyting_ins:9,addr_and_8bit_reg:8,al_and_num_ins:12,ax_and_num_ins:13,reg16bit_and_16bit_num:129,reg16bit_and_8bit_num:131,reg8bit_and_num:128,reg_num_sub_ins:200,addr16bit_and_16bit_num:129,addr16bit_and_8bit_num:131,addr8bit_and_num:128,addr_num_sub_ins:14,mdxType:"GenerateCompilationTable"}))}h.isMDXComponent=!0}}]);