"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4019],{2318:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>d,toc:()=>m});var i=n(7462),o=(n(7294),n(3905)),a=n(7898);const r={authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4"}},s="Support for memory, reg addressing for 2 operand instructions",d={permalink:"/emu_8086/blog/2023/11/1/",editUrl:"https://github.com/Sarath191181208/emu_8086/tree/main/docusaurus/blog/2023-11-1.mdx",source:"@site/blog/2023-11-1.mdx",title:"Support for memory, reg addressing for 2 operand instructions",description:"Changes this day :",date:"2023-11-01T00:00:00.000Z",formattedDate:"November 1, 2023",tags:[],readingTime:3.31,hasTruncateMarker:!1,authors:[{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}],frontMatter:{authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}},prevItem:{title:"Support for execution of OR ins",permalink:"/emu_8086/blog/2023/11/2/"},nextItem:{title:"\ud83d\udee0\ufe0f Refactor and Exec of AND",permalink:"/emu_8086/blog/2023/10/31/"}},l={authorsImageUrls:[void 0]},m=[{value:"Support for memory, reg addressing for 2 operand instructions",id:"support-for-memory-reg-addressing-for-2-operand-instructions",level:2},{value:"\ud83d\udc1eFIX: <code>MOV</code> mem, ax no compiling",id:"fix-mov-mem-ax-no-compiling",level:2},{value:"\ud83d\udc1eFIX: <code>ADD</code> ax, mem not compiling",id:"fix-add-ax-mem-not-compiling",level:2},{value:"\u2728 NEW: +compilation of <code>LEA</code> ins",id:"-new-compilation-of-lea-ins",level:2},{value:"\u2728 NEW: +execution of <code>LEA</code> ins",id:"-new-execution-of-lea-ins",level:2},{value:"\u2728 NEW: +compilation of <code>LES</code> ins",id:"-new-compilation-of-les-ins",level:2},{value:"\u2728 NEW: +execution of <code>LES</code> ins",id:"-new-execution-of-les-ins",level:2},{value:"Compilation of <code>OR</code> ins",id:"compilation-of-or-ins",level:2}],u={toc:m},p="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Changes this day :"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Added support for memory addressing for 2 operand instructions"),(0,o.kt)("li",{parentName:"ol"},"\ud83d\udc1eFIX: ",(0,o.kt)("inlineCode",{parentName:"li"},"MOV")," mem, ax no compiling"),(0,o.kt)("li",{parentName:"ol"},"\ud83d\udc1eFIX: ",(0,o.kt)("inlineCode",{parentName:"li"},"ADD")," ax, mem not compiling"),(0,o.kt)("li",{parentName:"ol"},"\u2728 NEW: +compilation of ",(0,o.kt)("inlineCode",{parentName:"li"},"LEA")," ins"),(0,o.kt)("li",{parentName:"ol"},"\u2728 NEW: +execution of ",(0,o.kt)("inlineCode",{parentName:"li"},"LEA")," ins")),(0,o.kt)("h2",{id:"support-for-memory-reg-addressing-for-2-operand-instructions"},"Support for memory, reg addressing for 2 operand instructions"),(0,o.kt)("p",null,"This is an example instruction"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"    MOV [0x100], Bx ; This was supported\n    MOV [BX+SI], AX ; Previously This wasn't supported\n")),(0,o.kt)("h2",{id:"fix-mov-mem-ax-no-compiling"},"\ud83d\udc1eFIX: ",(0,o.kt)("inlineCode",{parentName:"h2"},"MOV")," mem, ax no compiling"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MOV AX, 0x10 + 0x20")," kind of instructions weren't being compiled due to the lexer checking the wrong index for the instruction. This has been fixed in the fowlling way."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"                        &low_token => address_bytes.to_vec()\n                    )\n                );\n                // Removed\n                Ok(i + 3)\n                // Added\n                Ok(tokenized_line.len())\n            }\n        },\n        // MOV AX..DI, var\n")),(0,o.kt)("h2",{id:"fix-add-ax-mem-not-compiling"},"\ud83d\udc1eFIX: ",(0,o.kt)("inlineCode",{parentName:"h2"},"ADD")," ax, mem not compiling"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ADD AX, [0x100]")," kind of instructions weren't being compiled due to the lexer checking the wrong index for the instruction. This has been fixed in the fowlling way."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"                        &low_token => address_bytes.to_vec()\n                    )\n                );\n                // Removed\n                Ok(i + 3)\n                // Added\n                Ok(tokenized_line.len())\n            }\n        },\n        // ADD AX..DI, var\n")),(0,o.kt)("h2",{id:"-new-compilation-of-lea-ins"},"\u2728 NEW: +compilation of ",(0,o.kt)("inlineCode",{parentName:"h2"},"LEA")," ins"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LEA")," instruction is used to load the effective address of the source operand into the destination operand. This instruction is used to put the offset address of the source operand in the destination operand. The destination operand is always a register, and the source operand is always a memory operand. The source operand specifies the address of the data. The LEA instruction is useful for accessing table data and executing table lookup operations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"    LEA AX, [0x100] ; AX = 0x100\n    LEA AX, [BX+SI] ; AX = BX + SI\n    LEA AX, [BX+SI+0x100] ; AX = BX + SI + 0x100\n    LEA AX, [BX+SI+0x100+0x200] ; AX = BX + SI + 0x100 + 0x200\n")),(0,o.kt)("h2",{id:"-new-execution-of-lea-ins"},"\u2728 NEW: +execution of ",(0,o.kt)("inlineCode",{parentName:"h2"},"LEA")," ins"),(0,o.kt)("p",null,"The algorithm for the execution of the ",(0,o.kt)("inlineCode",{parentName:"p"},"LEA")," instruction is as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Fetch the instruction."),(0,o.kt)("li",{parentName:"ol"},"Decode the instruction to determine the addressing mode of the source operand."),(0,o.kt)("li",{parentName:"ol"},"Calculate the effective address of the source operand."),(0,o.kt)("li",{parentName:"ol"},"Load the effective address into the destination register."),(0,o.kt)("li",{parentName:"ol"},"Store the result in the destination register.")),(0,o.kt)("h2",{id:"-new-compilation-of-les-ins"},"\u2728 NEW: +compilation of ",(0,o.kt)("inlineCode",{parentName:"h2"},"LES")," ins"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"LES")," instruction is used to load double word register pair with a far pointer. The ",(0,o.kt)("inlineCode",{parentName:"p"},"LES")," instruction is used to load the segment register and the offset into the destination register pair. The destination operand is always a register, and the source operand is always a memory operand. The source operand specifies the address of the data. The ",(0,o.kt)("inlineCode",{parentName:"p"},"LES")," instruction is useful for accessing table data and executing table lookup operations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"    LES AX, [0x100] ; AX = [0x100], ES = [0x102]\n    LES AX, [BX+SI] ; AX = [BX + SI], ES = [BX + SI + 0x2]\n    LES AX, [BX+SI+0x100] ; AX = [BX + SI + 0x100 ] , ES = [BX + SI + 0x102]\n    LES AX, [BX+SI+0x100+0x200] ; AX = [BX + SI + 0x100 + 0x200], ES = [BX + SI + 0x302]\n")),(0,o.kt)("h2",{id:"-new-execution-of-les-ins"},"\u2728 NEW: +execution of ",(0,o.kt)("inlineCode",{parentName:"h2"},"LES")," ins"),(0,o.kt)("p",null,"The algorithm for the execution of the ",(0,o.kt)("inlineCode",{parentName:"p"},"LES")," instruction is as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Fetch the instruction."),(0,o.kt)("li",{parentName:"ol"},"Decode the instruction to determine the addressing mode of the source operand."),(0,o.kt)("li",{parentName:"ol"},"Calculate the effective address of the source operand."),(0,o.kt)("li",{parentName:"ol"},"Load the effective address into the destination register."),(0,o.kt)("li",{parentName:"ol"},"Store the result in the destination register."),(0,o.kt)("li",{parentName:"ol"},"Load the effective address + 2 into the extra segment register.")),(0,o.kt)("h2",{id:"compilation-of-or-ins"},"Compilation of ",(0,o.kt)("inlineCode",{parentName:"h2"},"OR")," ins"),(0,o.kt)("p",null,"It is used to perform bitwise or operation on the operands the result is stored in the first operand."),(0,o.kt)(a.YH,{instructionName:"OR",reg_16bit_and_anything_ins:11,reg_8bit_and_anything_ins:10,indexed_addressing_and_anyting_ins:9,addr_and_8bit_reg:8,al_and_num_ins:12,ax_and_num_ins:13,reg16bit_and_16bit_num:129,reg16bit_and_8bit_num:131,reg8bit_and_num:128,reg_num_sub_ins:200,addr16bit_and_16bit_num:129,addr16bit_and_8bit_num:131,addr8bit_and_num:128,addr_num_sub_ins:14,mdxType:"GenerateCompilationTable"}))}c.isMDXComponent=!0}}]);