"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9089],{7898:(e,n,t)=>{t.d(n,{PM:()=>s,PP:()=>h,Py:()=>u,VY:()=>i,W7:()=>o,YH:()=>_,kp:()=>g,lh:()=>d,mL:()=>c,qT:()=>E,vR:()=>m});var a=t(7294),r=t(614),l=t(3612);function i(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is either a general-purpose register or a segment register."),a.createElement("p",null,"Example:"),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`${e.instructionName} AX, BX \n${e.instructionName} BL, CH`),a.createElement("hr",null))}function m(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a constant."),a.createElement("p",null,"Example:"),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`${e.instructionName} AX, 0FFh \n${e.instructionName} BX, 0Bh  \n${e.instructionName} CL, 0h`),a.createElement("hr",null))}function s(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location."),a.createElement("p",null,"Example:"),a.createElement(r.Z,{language:"asm6502"},e.instructionName," AX, [0x100] ",a.createElement("br",null),e.instructionName," AL, b.[0x100] ",a.createElement("br",null)),"(or) Alternatively you can specify the memory location using the `variable assignment`",a.createElement("p",null,"Example"),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`ORG 100h \n.DATA\n  VAR1 DB 0FFh\n  VAR2 DW 0Bh\nCODE:\n  ${e.instructionName} AL, Var1 \n  ${e.instructionName} BX, Var2 \n  ${e.instructionName} CL, b.[Var2] \n  ${e.instructionName} DX, w.[Var1]`),a.createElement("hr",null))}function c(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location whose address is contained in a register."),a.createElement("p",null,"Example:"),a.createElement(r.Z,{language:"asm6502"},e.instructionName," AX, [BX] ",a.createElement("br",null),e.instructionName," AL, b.[BX] ",a.createElement("br",null)),a.createElement("hr",null))}function u(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location whose address is contained in a register and an offset."),a.createElement("p",null,"Example:"),a.createElement(r.Z,{language:"asm6502"},e.instructionName," AX, [BX+SI] ",a.createElement("br",null),e.instructionName," AL, b.[BX+SI] ",a.createElement("br",null)),a.createElement("hr",null))}function d(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified in the instruction itself. The operand is a memory location whose address is contained in a register and an offset and a displacement."),a.createElement("p",null,"Example:"),a.createElement(r.Z,{language:"asm6502"},e.instructionName," AX, [BX+SI+10h] ",a.createElement("br",null),e.instructionName," AX, [BX+SI+100h] ",a.createElement("br",null),e.instructionName," AL, b.[BX+SI+10h] ",a.createElement("br",null),e.instructionName," AL, b.[BX+SI+100h] ",a.createElement("br",null)),a.createElement("hr",null))}function o(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified as a register while the other operand is specified as a memory location. The second operand is a memory location whose address is contained in a register (or) an offset. The second operand might also have an displacement."),a.createElement("p",null,"Example: "),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`org 100h\ndata\n    VAR DB 0FFh\n    VAR2 DW 0Bh\ncode:\n    ${e.instructionName} BX, Var\n    ${e.instructionName} BX, w.[Var]\n    ${e.instructionName} BX, w.[Var2]\n    ${e.instructionName} AX, [BX]\n    ${e.instructionName} DX, [BX+SI]\n    ${e.instructionName} SP, [BX+SI+10h]\n    ${e.instructionName} DI, [BX+SI+100h]\n`))}function h(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified as a memory location while the other operand is specified as a register. The first operand is a memory location whose address is contained in a register (or) an offset. The first operand might also have an displacement."),a.createElement("p",null,"Example: "),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`org 100h\ndata\n    VAR DB 0FFh\n    VAR2 DW 0Bh\ncode:\n    ${e.instructionName} Var, BX\n    ${e.instructionName} w.[Var], BX\n    ${e.instructionName} w.[Var2], BX\n    ${e.instructionName} [BX], AX\n    ${e.instructionName} [BX+SI], DX\n    ${e.instructionName} [BX+SI+10h], SP\n    ${e.instructionName} [BX+SI+100h], DI\n`))}function E(e){return a.createElement(l.Z,{type:"danger",title:"Warning, This feature is still not supported."},a.createElement("p",null,"This is a mode in which the operand is specified as a memory location while the other operand is specified as a constant. The first operand is a memory location whose address is contained in a register (or) an offset. The first operand might also have an displacement."),a.createElement("p",null,"Example: "),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`${e.instructionName} [BX], 0FFh\n${e.instructionName} [BX+SI], 0FFh\n${e.instructionName} [BX+SI+10h], 0FFh\n${e.instructionName} [BX+SI+100h], 0FFh\n`))}function g(e){return a.createElement(a.Fragment,null,a.createElement("p",null,"This is a mode in which the operand is specified as a memory location while the other operand is specified as a constant. The first operand is a memory location whose address is specified directly in the instruction."),a.createElement("p",null,"Example: "),a.createElement(r.Z,{language:"asm6502",showLineNumbers:!0},`${e.instructionName} [BX], 0FFh\n${e.instructionName} [BX+SI], 0FFh\n${e.instructionName} [BX+SI+10h], 0FFh\n${e.instructionName} [BX+SI+100h], 0FFh\n`))}function _(e){return a.createElement("table",null,a.createElement("thead",null,a.createElement("tr",null,a.createElement("th",null,"Operand"),a.createElement("th",null,"Opcode"),a.createElement("th",null,"Size(bytes)"),a.createElement("th",null,"Example instruction"))),a.createElement("tbody",null,a.createElement("tr",null,a.createElement("td",null,"reg16, indirect mem"),a.createElement("td",null,e.reg_16bit_and_anything_ins," 0x00..=0x3F"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} AX, [BX]`)),a.createElement("tr",null,a.createElement("td",null,"reg16, direct mem"),a.createElement("td",null,e.reg_16bit_and_anything_ins," ","0x06 | reg_idx << 3"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} DX, [0x100]`)),a.createElement("tr",null,a.createElement("td",null,"reg16, indirect mem with 8bit offset"),a.createElement("td",null,e.reg_16bit_and_anything_ins," 0x40..=0x7F 0x00..=0xFF"),a.createElement("td",null,"3"),a.createElement("td",null,`${e.instructionName} AX, [BX+0x10]`)),a.createElement("tr",null,a.createElement("td",null,"reg16, indirect mem with 16bit offset"),a.createElement("td",null,e.reg_16bit_and_anything_ins," 0x80..=0xBF 0x00..=0xFF"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} AX, [BX+0x100]`)),a.createElement("tr",null,a.createElement("td",null,"reg16, reg16"),a.createElement("td",null,e.reg_16bit_and_anything_ins," 0xC0..=0xFF"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} AX, BX`)),a.createElement("tr",null,a.createElement("td",null,"reg8, indirect mem"),a.createElement("td",null,e.reg_8bit_and_anything_ins," 0x00..=0x3F"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} AL, [BX]`)),a.createElement("tr",null,a.createElement("td",null,"reg8, direct mem"),a.createElement("td",null,e.reg_8bit_and_anything_ins," ","0x06 | reg_idx << 3"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} CL, [0x100]`)),a.createElement("tr",null,a.createElement("td",null,"reg8, indirect mem with 8bit offset"),a.createElement("td",null,e.reg_8bit_and_anything_ins," 0x40..=0x7F 0x00..=0xFF"),a.createElement("td",null,"3"),a.createElement("td",null,`${e.instructionName} AL, [BX+0x10]`)),a.createElement("tr",null,a.createElement("td",null,"reg8, indirect mem with 16bit offset"),a.createElement("td",null,e.reg_8bit_and_anything_ins," 0x80..=0xBF 0x00..=0xFF"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} AL, [BX+0x100]`)),a.createElement("tr",null,a.createElement("td",null,"reg8, reg8"),a.createElement("td",null,e.reg_8bit_and_anything_ins," 0xC0..=0xFF"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} AL, BL`)),a.createElement("tr",null,a.createElement("td",null,"indirect mem, reg 16"),a.createElement("td",null,e.indexed_addressing_and_anyting_ins," 0x00..=0x3F"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} [BX+SI], AX`)),a.createElement("tr",null,a.createElement("td",null,"direct mem, reg 16"),a.createElement("td",null,e.indexed_addressing_and_anyting_ins," ","0x06 | reg_idx << 3"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} [0x100], BP`)),a.createElement("tr",null,a.createElement("td",null,"indirect mem with 8bit offset, reg 16"),a.createElement("td",null,e.indexed_addressing_and_anyting_ins," 0x40..=0x7F 0x00..=0xFF"),a.createElement("td",null,"3"),a.createElement("td",null,`${e.instructionName} [BX+SI+0x10], CX`)),a.createElement("tr",null,a.createElement("td",null,"indirect mem with 16bit offset, reg 16"),a.createElement("td",null,e.indexed_addressing_and_anyting_ins," 0x80..=0xBF 0x00..=0xFF"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} [BX+SI+0x100], DX`)),a.createElement("tr",null,a.createElement("td",null,"direct mem, reg 8"),a.createElement("td",null,e.addr_and_8bit_reg," ","0x06 | reg_idx << 3"),a.createElement("td",null,"4"),a.createElement("td",null,`${e.instructionName} [0x100], AL`)),a.createElement("tr",null,a.createElement("td",null,"AL, num"),a.createElement("td",null,e.al_and_num_ins," 0x00..=0xFF 0x00..=0xFF"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} AL, 0x10`)),a.createElement("tr",null,a.createElement("td",null,"AX, num"),a.createElement("td",null,e.ax_and_num_ins," 0x00..=0xFF 0x00..=0xFF"),a.createElement("td",null,"3"),a.createElement("td",null,`${e.instructionName} AX, 0x100`)),a.createElement("tr",null,a.createElement("td",null,"reg16, num16"),a.createElement("td",null,e.reg16bit_and_16bit_num," ",e.reg_num_sub_ins,"+reg_idx 0x00..=0xFF 0x00..=0xFF"),a.createElement("td",null,"3"),a.createElement("td",null,`${e.instructionName} DX, 0x100`)),a.createElement("tr",null,a.createElement("td",null,"reg16, num8"),a.createElement("td",null,e.reg16bit_and_8bit_num," ",e.reg_num_sub_ins,"+reg_idx 0x00..=0xFF"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} CX, 0x10`)),a.createElement("tr",null,a.createElement("td",null,"reg8, num"),a.createElement("td",null,e.reg8bit_and_num," ",e.reg_num_sub_ins,"+reg_idx 0x00..=0xFF"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} AL, 0x10`)),a.createElement("tr",null,a.createElement("td",null,"direct address, num16"),a.createElement("td",null,e.addr16bit_and_16bit_num," ",e.addr_num_sub_ins,"+reg_idx"," ","[0x00..=0xFF 0x00..=0xFF] 0x00..=0xFF 0x00..=0xFF"),a.createElement("td",null,"6"),a.createElement("td",null,`${e.instructionName} [0x100], 0x100`)),a.createElement("tr",null,a.createElement("td",null,"direct address, num8"),a.createElement("td",null,e.addr16bit_and_16bit_num," ",e.addr_num_sub_ins,"+reg_idx"," ","[0x00..=0xFF 0x00..=0xFF] 0x00..=0xFF"," "),a.createElement("td",null,"5"),a.createElement("td",null,`${e.instructionName} [0x100], 0x10`)),a.createElement("tr",null,a.createElement("td",null,"addr8, num"),a.createElement("td",null,e.addr8bit_and_num," ",e.addr_num_sub_ins,"+reg_idx [0x00..=0xFF 0x00..=0xFF] 0x00..=0xFF"),a.createElement("td",null,"2"),a.createElement("td",null,`${e.instructionName} b.[0x100], 0x10`))))}},7639:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>m,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=t(7462),r=(t(7294),t(3905)),l=t(7898);const i={authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4"}},m="Support for of SBB ins",s={permalink:"/emu_8086/blog/2023/11/3/",editUrl:"https://github.com/Sarath191181208/emu_8086/tree/main/docusaurus/blog/2023-11-3.mdx",source:"@site/blog/2023-11-3.mdx",title:"Support for of SBB ins",description:"Compilation of SBB ins",date:"2023-11-03T00:00:00.000Z",formattedDate:"November 3, 2023",tags:[],readingTime:1.385,hasTruncateMarker:!1,authors:[{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}],frontMatter:{authors:{name:"Vangipuram Srinivasa Sarath Chandra",title:"Tech enthusiast",url:"https://github.com/Sarath191181208",image_url:"https://avatars.githubusercontent.com/u/74459981?v=4",imageURL:"https://avatars.githubusercontent.com/u/74459981?v=4"}},nextItem:{title:"Support for execution of OR ins",permalink:"/emu_8086/blog/2023/11/2/"}},c={authorsImageUrls:[void 0]},u=[{value:"Compilation of <code>SBB</code> ins",id:"compilation-of-sbb-ins",level:2},{value:"\ud83d\udee0\ufe0f Refactor: extracted common consume logic in cpu",id:"\ufe0f-refactor-extracted-common-consume-logic-in-cpu",level:2},{value:"\u2728 NEW: Support xchg instruction",id:"-new-support-xchg-instruction",level:2}],d={toc:u},o="wrapper";function h(e){let{components:n,...t}=e;return(0,r.kt)(o,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"compilation-of-sbb-ins"},"Compilation of ",(0,r.kt)("inlineCode",{parentName:"h2"},"SBB")," ins"),(0,r.kt)("p",null,"It is used to subtract the second operand from the first operand along with the borrow flag. The result is stored in the first operand. The flags are modified accordingly. The operands may be registers or memory locations. The first operand is also called the destination operand and the second operand is called the source operand. The destination operand can be a register or a memory location; the source operand can be an immediate, register, or memory location. (However, two memory operands cannot be used in one instruction.) When an immediate value is used as an operand, it is sign-extended to the length of the destination operand format."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-asm6502",metastring:"showLineNumbers",showLineNumbers:!0},"SBB AX, BX\n")),(0,r.kt)(l.YH,{instructionName:"SBB",reg_16bit_and_anything_ins:27,reg_8bit_and_anything_ins:26,indexed_addressing_and_anyting_ins:25,addr_and_8bit_reg:24,al_and_num_ins:28,ax_and_num_ins:29,reg16bit_and_16bit_num:129,reg16bit_and_8bit_num:131,reg8bit_and_num:128,reg_num_sub_ins:216,addr16bit_and_16bit_num:129,addr16bit_and_8bit_num:131,addr8bit_and_num:128,addr_num_sub_ins:30,mdxType:"GenerateCompilationTable"}),(0,r.kt)("h2",{id:"\ufe0f-refactor-extracted-common-consume-logic-in-cpu"},"\ud83d\udee0\ufe0f Refactor: extracted common consume logic in cpu"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:"showLineNumbers",showLineNumbers:!0},"// Removed\nmatch ins {\n    // Removed\n    0x06 | 0x0E | 0x16 | 0x1E | 0x26 | 0x2E | 0x36 | 0x3E => {\n    // Removed\n        // ...\n    // Removed\n    }\n    // Removed\n    0x00..=0x3F => {\n    // Removed\n        // ...\n    // Removed\n    }\n    // Removed\n    0x40..=0x7F => {\n    // Removed\n        // ...\n    // Removed\n    }\n    // Removed\n    0x80..=0xBF => {\n    // Removed\n        // ...\n    // Removed\n    }\n// Removed\n}\n\n// replaced with\n// Added\nmatch self.consume_bytes_and_parse_double_ins(mem) {\n    // Added\n    AddressingMode::Address(reg_idx, addr) => {\n        // Added\n        // ...  \n    // Added\n    }\n    // Added\n    AddressingMode::Reg(reg_idx, low_reg) => {\n        // Added\n        // ...\n    // Added\n    }\n// Added\n}\n")),(0,r.kt)("h2",{id:"-new-support-xchg-instruction"},"\u2728 NEW: Support xchg instruction"),(0,r.kt)("p",null,"Made the ",(0,r.kt)("inlineCode",{parentName:"p"},"xchg")," instruction work with all the addressing modes."))}h.isMDXComponent=!0}}]);